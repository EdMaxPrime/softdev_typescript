<!DOCTYPE html>
<html>
<head>
	<title>TypeScript Presentation</title>
	<style type="text/css">
		.slide {border-bottom: 2px solid #888;}
		.centered {text-align: center;}
		body {
			padding: 40px;
			font-size: 24px;
		}
		#top {
			padding: 10px;
			background-color: rgb(32, 64, 105);
			color: white;
			font-family: sans-serif;
		}
        #top table {
            table-layout: fixed;
            margin: auto auto;
        }
        #top table td {padding: 0px 15px;}
        #top a {
            color: white; 
            text-decoration: none;
        }
        #top a:hover {text-decoration: underline;}
		p, ol {
			line-height: 2em;
			padding: 20px;
		}
		pre, code {
			padding: 0;
			margin-left: 0;
			margin-right: 0;
			font-size: 18px;
		}
        table.compare {
            table-layout: fixed;
            width: 100%;
        }
        #scrolltop {
            display: inline-block;
            position: fixed;
            padding: 10px;
            bottom: 10px;
            right: 10px;
            text-transform: uppercase;
            text-decoration: none;
            background-color: #ddd;
            color: rgb(32, 64, 105);
        }
        a.button {
            display: inline-block;
            padding: 9px;
            margin: 10px 50px; /*10 vertically and 50 horizontally*/
            background-color: #B0D3E1; /*#FFB3B8;*/
            text-transform: uppercase;
            text-decoration: none;
            font-family: sans-serif;
            font-weight: 600;
            color: black;
        }
        a.button:hover {color: white;}
	</style>
	<link rel="stylesheet" href="highlight/styles/solarized-light.css" />
</head>
<body>
	<div id="top">
        <h1 class="centered">Features of TypeScript</h1>
        <table>
            <tr><td><a href="#ex0">Var vs. Let</a></td>         <td><a href="#ex10">Type Annotations</a></td></tr>
            <tr><td><a href="#ex1">Rest Parameters</a></td>     <td><a href="#ex11">Type Inferencing</a></td></tr>
            <tr><td><a href="#ex2">Optional Parameters</a></td> <td><a href="#ex12">Interfaces</a></td></tr>
            <tr><td><a href="#ex3">Default Parameters</a></td>  <td><a href="#ex13">Classes</a></td></tr>
        </table>
    </div>
    <div style="background-color: #C9F1FF; padding: 20px; line-height: 1.5em;">
        Click on a topic above to learn more about it. Each of the topics have a code sample to go along with it. Please note that, depending on your internet browser's window size, some of those side-by-side code comparisons may turn into side-scrolling adventures. If that's the case, keep in mind the code isn't cut off, you just need to swipe left to see it. <br> In the lower right corner is a button that will bring you back up to this index. <br> Below are links to the home page, which is about TypeScript as a whole, and to the official documentation.<br>
	    <div class="centered"><a class="button" href="index.html">general info</a><a class="button" href="http://typescriptlang.org">documentation</a></div>
    </div>
    <div id="ex0" class="slide">
		<h2>Var vs. Let</h2>
		<p style="padding-top: 5px; padding-bottom: 5px;">In TypeScript the keyword <b>let</b> is used in preference to JavaScript's <b>var</b> because it confines variables to the scope/block they were defined in, and it doesn't let you redeclare a variable twice.</p>
        <table class="compare">
            <tr><th>Redeclaring</th><th>Not Scoped</th></tr>
            <tr>
                <td><pre><code class="js">
var zoinks = function(scary) {
    var message = "yikes"
    if(scary == true) {
        var message = "jinkies";
    }
    console.log(message);
}
zoinks(false); //prints "yikes"
zoinks(true);  //prints "jinkies"
                </code></pre></td>
                <td><pre><code class="js">
var count = function() {
    for(var i = 0; i < 10; i++) {
        setTimeout(function() {
            console.log(i);
        }, 1000);
    }
}
count(); //prints "10" ten times

                </code></pre></td>
            </tr>
        </table>
        <p>In the first example (left), the issue with redeclaring variables becomes apparent. The code is valid JavaScript and will print "yikes" or "zoinks" depending on the value of the parameter. However, the variable message is declared twice <i>and</i> it's in a nested block (inside the if statement). This is weird because it blurs the line between declaring/initializing, and it undermines the concept of nesting scopes in JS. A Scooby Doo catchphrase would be apt here. But fear not. With the <b>let</b> keyword, you would get an error for both of those violations.</p>
        <p>In the second example (right), the count function tries to print the numbers 0-9 with one second intervals. Surprisingly, that is not what this code does. This is because the variable i isn't captured at the moment the loop is executed, but rather when the timeout function is run. So the for loop will increment i to 10 by the time the timeout happens. Understandably, this can be frustrating. The <b>let</b> keyword would work better in place of <b>var</b> here because it will capture i while the loop is happening, allowing you to print 0-9.</p>
	</div>
    <div id="ex1" class="slide">
        <h2>Rest Parameters</h2>
        <p>Rest parameters are treated like a boundless amount of optional parameters. They are denoted by an ellipsis (...) before a variable. Rest parameters can be very helpful if you do not know how many paramaters your function will take or if you want to work with multiple parameters as a group. Below we show how rest parameters make writing a summation function very easy.</p>
        <table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
//rest
let add = function(...a) {
    let sum = 0;
    for(let i = 0; i < a.length; i++) {
        sum += a[i];
    }
    return sum;
};
console.log(add(1)); //should be 1
console.log(add(1, 2, 3)); //should be 6




        </code></pre></td>
                <td><pre><code class="javascript">
//rest
var add = function () {
    var a = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        a[_i] = arguments[_i];
    }
    var sum = 0;
    for (var i = 0; i < a.length; i++) {
        sum += a[i];
    }
    return sum;
};
console.log(add(1)); //should be 1
console.log(add(1, 2, 3)); //should be 6
                </code></pre></td>
            </tr>
        </table>
    </div>
    <div id="ex2" class="slide">
        <h2>Optional Parameters</h2>
        <p>Optional parameters are pretty self explanatory. In TypeScript you can make a parameter to a function optional by putting a '?' after the variable name. This functionality mimics JavaScript in which all parameters are optional. In TypeScript, optional parameters must follow required parameters (be the last ones defined).</p>
        <table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
//the last parameter is optional
let greet = function(first, last?) {
    console.log(first + " " + last);
};
console.log(greet("Bond")); //Bond
console.log(greet("James", "Bond")); //James Bond
        </code></pre></td>
                <td><pre><code class="javascript">
//the last parameter is optional
var greet = function(first, last?) {
    console.log(first + " " + last);
};
console.log(greet("Bond")); //Bond
console.log(greet("James", "Bond")); //James Bond
                </code></pre></td>
            </tr>
        </table>
    </div>
    <div id="ex3" class="slide">
        <h2>Default Parameters</h2>
        <p>TypeScript allows you to set a default value for a parameter that will be used if the user does not provide one or if the user passes 'undefined'. Default parameters are denoted by including '= VALUE' after a parameter name. If default parameters are defined after all required parameters they will be treated as optional and the default value can be triggered by calling the function without the parameter. If the default parameter is between required parameters, however, the default value will only be triggered if the user passes 'undefined' as the parameter value.</p>
    	<table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
//the year parameter's default value is 2018
let dateFormat = function(day, month, year=2018) {
    console.log(day + "/" + month + "/" + year);
};
console.log(dateFormat(3, 16));
console.log(dateFormat(3, 16, 2017));           

                </code></pre></td>
                <td><pre><code class="javscript">
//the year parameter's default value is 2018
var dateFormat = function(day, month, year) {
    if(year == void 0) { year = 2018; }
    console.log(day + "/" + month + "/" + year);
};
console.log(dateFormat(3, 16));
console.log(dateFormat(3, 16, 2017));  
                </code></pre></td>
            </tr>
        </table>
	</div>
	<div id="ex10" class="slide">
		<h2>Type Annotations</h2>
        <p>As one might assume from the name 'TypeScript', Typescript is a statically typed language. This is a way in which the language presents itself a lot more like Java than JavaScript. The four basic data types in TypeScript are: number, boolean, string, and any. The any type allows you to bypass static typing, as an any type variable becomes functionally dynamically typed. The colon is used to denote type in TypeScript. The following examples show how type annotations work in more detail. Note that the errors mentioned in the code sample are compile-time errors.</p>
		<table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
let amount : number = 5; //defines variable amount as a number
amount = 42;
amount = true; //error because true is not a number
let name : string = "DW"; //defines variable name as a string
name = []; //error because a list is not a string
let yesno : boolean = true; //defines variable yesno as a boolean
yesno = false;
let random : any = "pizza"; //defines variable random as any
random = 5; //ok
random = true; //ok

//parameters can also be typed
let repeat = function(str : string, times : number) : string {
    result = "";
    while(times > 0) {
        result += str;
    }
    return result;
};

console.log(repeat("hi", 3));
console.log(repeat(5, 8)); //error, expected the first argument to be a string
                </code></pre></td>
                <td><pre><code class="javascript">
var amount = 5;
amount = 42;
amount = true;
var name = "DW";
name = {}; 
var yesno = true;
yesno = false;
var random = "pizza";
random = 5; 
random = true;


var repeat = function (str, times) {
    result = "";
    while (times > 0) {
        result += str;
    }
    return result;
};

console.log(repeat("hi", 3));
console.log(repeat(5, 8));
                </code></pre></td>
            </tr>
        </table>
	</div>
	<div id="ex11" class="slide">
	    <h3>Type Inferencing</h3>
        <p>If it walks like a duck, looks like a duck, and sounds like a duck, then it's a duck. This quote explains "duck typing," which in TS is called Type Inferencing. This means that not all variables have to have their type explicitly declared. The compiler can figure out from context what the type of a variable should be.</p>
	    <table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
let myVar = 5; //assumed to be a number
myVar = true; //error, expected a number not boolean

//TypeScript infers that isOnScreen returns boolean
let isOnScreen = function(point: {x: number; y: number}) {
    return (point.x > 0 && point.y > 0 && point.x < 500 && point.y < 500);
};

let circle = {x: 5, y: 50, radius: 10, fill: "green"};
let square = {x: 50, y: 5, side: 10, fill: "blue"};
let mouseEvent = {x: 50, y: 5};

console.log(isOnScreen(circle));
console.log(isOnScreen(square));
console.log(isOnScreen(mouseEvent));

//Do you think this needs to be fixed?
let listener = function(event) {
    console.log(event.button);
};
                </code></pre></td>
                <td><pre><code class="javascript">
var myVar = 5; 
myVar = true; //this is ok in JS

//Returns true if the point is within the bounds, assumes it has X and Y
var isOnScreen = function(point) {
    return (point.x > 0 && point.y > 0 && point.x < 500 && point.y < 500);
};

var circle = {x: 5, y: 50, radius: 10, fill: "green"};
var square = {x: 50, y: 5, side: 10, fill: "blue"};
var mouseEvent = {x: 50, y: 5};

console.log(isOnScreen(circle));
console.log(isOnScreen(square));
console.log(isOnScreen(mouseEvent));

//Do you think this needs to be fixed?
var listener = function(event) {
    console.log(event.button);
};
                </code></pre></td>
            </tr>
        </table>
        <p>Yes, the listener function needs to be fixed. The type of "event" is assumed to be Object, however, this is not the same thing as "any." It's actually more like Java's Object type, which only has a toString() and equals() but nothing else. Trying to access the button property of the event variable would therefor give a compile-time error. To fix it, you need to explicitly state that the event parameter is of type any, or is an object with the button property.</p>
	</div>
	<div id="ex12" class="slide">
		<h3>Interfaces</h3>
        <p>Hello Java my old friend... I've come to implement with you again. Yes, there are interfaces in this language too! While interfaces are really useful for class-based programming, they can also be used to make type inferencing a lot more powerful. Say you need more than just a number or a string, perhaps a book. If you need to quickly define a more complex data structure, an interface is the best way to do it. And because interfaces can't be instantiated (unlike classes), TS has no choice but to infer that an object "implements" an interface, such as the harryPotter variable below.</p>
		<table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="typescript">
interface Book {
    title : string;
    author : string;
}
let book_info = function(book : Book) : string {
    return "Title: " + book.title + ", Author: " + book.author;
}
let harryPotter = {title : "Harry Potter", author : "JK Rowling"};
console.log(book_info(harryPotter));
                </code></pre></td>
                <td><pre><code class="javascript">
var book_info = function(book) : string {
    return "Title: " + book.title + ", Author: " + book.author;
}
var harryPotter = {title : "Harry Potter", author : "JK Rowling"};
console.log(book_info(harryPotter));




                </code></pre></td>
            </tr>
        </table>
        
	</div>
	<div id="ex13" class="slide">
		<h3>Classes</h3>
        <p>Although JavaScript is an object-oriented language, it does not support classes. TypeScript fills this gap. It has classes, inheritance, public/private/protected fields, static variables, and readonly properties. The basic structure of classes and an example of inheritance is shown below. Classes may only have one constructor, and it is the function named <b>constructor</b>. All instance variables are public by default. To change this, prepend the keywords <b>private</b> or <b>protected</b> to the declaration. Read-only variables can't be modified from outside the class. To make one, prepend the keyword <b>readonly</b> to the declaration.</p>
        <table class="compare">
            <tr><th>TypeScript</th><th>JavaScript</th></tr>
            <tr>
                <td><pre><code class="ts">
class Animal {
    taxonomy : string;
    constructor(public family: string, public genus: string, public species: string) {
        this.taxonomy = family + " " + genus + " " + species;
    }
}

let bob : Animal = new Animal("Hominidae", "Homo", "Sapien");

//Inheritance!!!
class Dog extends Animal {
    name : string;
    constructor(public name: string) {
        super("Canidae", "Canis", "Lupus");
    }
    bark() {
        console.log(this.name + " just barked you!");
    }
}

let greatDane = new Dog("Scooby Doo");
greatDane.bark();
                </code></pre></td>
                <td><pre><code class="js">
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Animal = /** @class */ (function () {
    function Animal(family, genus, species) {
        this.family = family;
        this.genus = genus;
        this.species = species;
        this.taxonomy = family + " " + genus + " " + species;
    }
    return Animal;
}());
var bob = new Animal("Hominidae", "Homo", "Sapien");
//Inheritance!!!
var Dog = /** @class */ (function (_super) {
    __extends(Dog, _super);
    function Dog(name) {
        var _this = _super.call(this, "Canidae", "Canis", "Lupus") || this;
        _this.name = name;
        return _this;
    }
    Dog.prototype.bark = function () {
        console.log(this.name + " just barked you!");
    };
    return Dog;
}(Animal));
var greatDane = new Dog("Scooby Doo");
greatDane.bark();
                </code></pre></td>
            </tr>
        </table>
        <p>You may notice that the Animal constructor had the word "public" in front of the names of its parameters. This is TypeScript shorthand. It will take those parameters and make them instance variables automatically, giving them the value from the constructor.</p>
        
	</div>
    <a id="scrolltop" href="#top">top</a>
	<script type="text/javascript" src="highlight/highlight.pack.js"></script>
	<script type="text/javascript">
	    hljs.initHighlightingOnLoad();
	</script>
</body>
</html>

















